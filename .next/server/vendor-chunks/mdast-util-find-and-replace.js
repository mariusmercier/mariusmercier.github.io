"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/mdast-util-find-and-replace";
exports.ids = ["vendor-chunks/mdast-util-find-and-replace"];
exports.modules = {

/***/ "(rsc)/./node_modules/mdast-util-find-and-replace/lib/index.js":
/*!***************************************************************!*\
  !*** ./node_modules/mdast-util-find-and-replace/lib/index.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   findAndReplace: () => (/* binding */ findAndReplace)\n/* harmony export */ });\n/* harmony import */ var escape_string_regexp__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! escape-string-regexp */ \"(rsc)/./node_modules/mdast-util-find-and-replace/node_modules/escape-string-regexp/index.js\");\n/* harmony import */ var unist_util_visit_parents__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! unist-util-visit-parents */ \"(rsc)/./node_modules/unist-util-visit-parents/lib/index.js\");\n/* harmony import */ var unist_util_is__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! unist-util-is */ \"(rsc)/./node_modules/unist-util-is/lib/index.js\");\n/**\n * @import {Nodes, Parents, PhrasingContent, Root, Text} from 'mdast'\n * @import {BuildVisitor, Test, VisitorResult} from 'unist-util-visit-parents'\n */\n\n/**\n * @typedef RegExpMatchObject\n *   Info on the match.\n * @property {number} index\n *   The index of the search at which the result was found.\n * @property {string} input\n *   A copy of the search string in the text node.\n * @property {[...Array<Parents>, Text]} stack\n *   All ancestors of the text node, where the last node is the text itself.\n *\n * @typedef {RegExp | string} Find\n *   Pattern to find.\n *\n *   Strings are escaped and then turned into global expressions.\n *\n * @typedef {Array<FindAndReplaceTuple>} FindAndReplaceList\n *   Several find and replaces, in array form.\n *\n * @typedef {[Find, Replace?]} FindAndReplaceTuple\n *   Find and replace in tuple form.\n *\n * @typedef {ReplaceFunction | string | null | undefined} Replace\n *   Thing to replace with.\n *\n * @callback ReplaceFunction\n *   Callback called when a search matches.\n * @param {...any} parameters\n *   The parameters are the result of corresponding search expression:\n *\n *   * `value` (`string`) — whole match\n *   * `...capture` (`Array<string>`) — matches from regex capture groups\n *   * `match` (`RegExpMatchObject`) — info on the match\n * @returns {Array<PhrasingContent> | PhrasingContent | string | false | null | undefined}\n *   Thing to replace with.\n *\n *   * when `null`, `undefined`, `''`, remove the match\n *   * …or when `false`, do not replace at all\n *   * …or when `string`, replace with a text node of that value\n *   * …or when `Node` or `Array<Node>`, replace with those nodes\n *\n * @typedef {[RegExp, ReplaceFunction]} Pair\n *   Normalized find and replace.\n *\n * @typedef {Array<Pair>} Pairs\n *   All find and replaced.\n *\n * @typedef Options\n *   Configuration.\n * @property {Test | null | undefined} [ignore]\n *   Test for which nodes to ignore (optional).\n */\n\n\n\n\n\n/**\n * Find patterns in a tree and replace them.\n *\n * The algorithm searches the tree in *preorder* for complete values in `Text`\n * nodes.\n * Partial matches are not supported.\n *\n * @param {Nodes} tree\n *   Tree to change.\n * @param {FindAndReplaceList | FindAndReplaceTuple} list\n *   Patterns to find.\n * @param {Options | null | undefined} [options]\n *   Configuration (when `find` is not `Find`).\n * @returns {undefined}\n *   Nothing.\n */\nfunction findAndReplace(tree, list, options) {\n  const settings = options || {};\n  const ignored = (0,unist_util_is__WEBPACK_IMPORTED_MODULE_1__.convert)(settings.ignore || []);\n  const pairs = toPairs(list);\n  let pairIndex = -1;\n  while (++pairIndex < pairs.length) {\n    (0,unist_util_visit_parents__WEBPACK_IMPORTED_MODULE_2__.visitParents)(tree, 'text', visitor);\n  }\n\n  /** @type {BuildVisitor<Root, 'text'>} */\n  function visitor(node, parents) {\n    let index = -1;\n    /** @type {Parents | undefined} */\n    let grandparent;\n    while (++index < parents.length) {\n      const parent = parents[index];\n      /** @type {Array<Nodes> | undefined} */\n      const siblings = grandparent ? grandparent.children : undefined;\n      if (ignored(parent, siblings ? siblings.indexOf(parent) : undefined, grandparent)) {\n        return;\n      }\n      grandparent = parent;\n    }\n    if (grandparent) {\n      return handler(node, parents);\n    }\n  }\n\n  /**\n   * Handle a text node which is not in an ignored parent.\n   *\n   * @param {Text} node\n   *   Text node.\n   * @param {Array<Parents>} parents\n   *   Parents.\n   * @returns {VisitorResult}\n   *   Result.\n   */\n  function handler(node, parents) {\n    const parent = parents[parents.length - 1];\n    const find = pairs[pairIndex][0];\n    const replace = pairs[pairIndex][1];\n    let start = 0;\n    /** @type {Array<Nodes>} */\n    const siblings = parent.children;\n    const index = siblings.indexOf(node);\n    let change = false;\n    /** @type {Array<PhrasingContent>} */\n    let nodes = [];\n    find.lastIndex = 0;\n    let match = find.exec(node.value);\n    while (match) {\n      const position = match.index;\n      /** @type {RegExpMatchObject} */\n      const matchObject = {\n        index: match.index,\n        input: match.input,\n        stack: [...parents, node]\n      };\n      let value = replace(...match, matchObject);\n      if (typeof value === 'string') {\n        value = value.length > 0 ? {\n          type: 'text',\n          value\n        } : undefined;\n      }\n\n      // It wasn’t a match after all.\n      if (value === false) {\n        // False acts as if there was no match.\n        // So we need to reset `lastIndex`, which currently being at the end of\n        // the current match, to the beginning.\n        find.lastIndex = position + 1;\n      } else {\n        if (start !== position) {\n          nodes.push({\n            type: 'text',\n            value: node.value.slice(start, position)\n          });\n        }\n        if (Array.isArray(value)) {\n          nodes.push(...value);\n        } else if (value) {\n          nodes.push(value);\n        }\n        start = position + match[0].length;\n        change = true;\n      }\n      if (!find.global) {\n        break;\n      }\n      match = find.exec(node.value);\n    }\n    if (change) {\n      if (start < node.value.length) {\n        nodes.push({\n          type: 'text',\n          value: node.value.slice(start)\n        });\n      }\n      parent.children.splice(index, 1, ...nodes);\n    } else {\n      nodes = [node];\n    }\n    return index + nodes.length;\n  }\n}\n\n/**\n * Turn a tuple or a list of tuples into pairs.\n *\n * @param {FindAndReplaceList | FindAndReplaceTuple} tupleOrList\n *   Schema.\n * @returns {Pairs}\n *   Clean pairs.\n */\nfunction toPairs(tupleOrList) {\n  /** @type {Pairs} */\n  const result = [];\n  if (!Array.isArray(tupleOrList)) {\n    throw new TypeError('Expected find and replace tuple or list of tuples');\n  }\n\n  /** @type {FindAndReplaceList} */\n  // @ts-expect-error: correct.\n  const list = !tupleOrList[0] || Array.isArray(tupleOrList[0]) ? tupleOrList : [tupleOrList];\n  let index = -1;\n  while (++index < list.length) {\n    const tuple = list[index];\n    result.push([toExpression(tuple[0]), toFunction(tuple[1])]);\n  }\n  return result;\n}\n\n/**\n * Turn a find into an expression.\n *\n * @param {Find} find\n *   Find.\n * @returns {RegExp}\n *   Expression.\n */\nfunction toExpression(find) {\n  return typeof find === 'string' ? new RegExp((0,escape_string_regexp__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(find), 'g') : find;\n}\n\n/**\n * Turn a replace into a function.\n *\n * @param {Replace} replace\n *   Replace.\n * @returns {ReplaceFunction}\n *   Function.\n */\nfunction toFunction(replace) {\n  return typeof replace === 'function' ? replace : function () {\n    return replace;\n  };\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbWRhc3QtdXRpbC1maW5kLWFuZC1yZXBsYWNlL2xpYi9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUV5QztBQUNZO0FBQ2hCOztBQUVyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLFNBQVNHLGNBQWNBLENBQUNDLElBQUksRUFBRUMsSUFBSSxFQUFFQyxPQUFPLEVBQUU7RUFDbEQsTUFBTUMsUUFBUSxHQUFHRCxPQUFPLElBQUksQ0FBQyxDQUFDO0VBQzlCLE1BQU1FLE9BQU8sR0FBR04sc0RBQU8sQ0FBQ0ssUUFBUSxDQUFDRSxNQUFNLElBQUksRUFBRSxDQUFDO0VBQzlDLE1BQU1DLEtBQUssR0FBR0MsT0FBTyxDQUFDTixJQUFJLENBQUM7RUFDM0IsSUFBSU8sU0FBUyxHQUFHLENBQUMsQ0FBQztFQUVsQixPQUFPLEVBQUVBLFNBQVMsR0FBR0YsS0FBSyxDQUFDRyxNQUFNLEVBQUU7SUFDakNaLHNFQUFZLENBQUNHLElBQUksRUFBRSxNQUFNLEVBQUVVLE9BQU8sQ0FBQztFQUNyQzs7RUFFQTtFQUNBLFNBQVNBLE9BQU9BLENBQUNDLElBQUksRUFBRUMsT0FBTyxFQUFFO0lBQzlCLElBQUlDLEtBQUssR0FBRyxDQUFD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S0FBSyxDQUFDQyxPQUFPLENBQUNHLFdBQVcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUM1Q0EsV0FBVyxHQUNYLENBQUNBLFdBQVcsQ0FBQztFQUVuQixJQUFJNUIsS0FBSyxHQUFHLENBQUMsQ0FBQztFQUVkLE9BQU8sRUFBRUEsS0FBSyxHQUFHWixJQUFJLENBQUNRLE1BQU0sRUFBRTtJQUM1QixNQUFNbUMsS0FBSyxHQUFHM0MsSUFBSSxDQUFDWSxLQUFLLENBQUM7SUFDekI2QixNQUFNLENBQUNQLElBQUksQ0FBQyxDQUFDVSxZQUFZLENBQUNELEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFRSxVQUFVLENBQUNGLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7RUFDN0Q7RUFFQSxPQUFPRixNQUFNO0FBQ2Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVNHLFlBQVlBLENBQUN4QixJQUFJLEVBQUU7RUFDMUIsT0FBTyxPQUFPQSxJQUFJLEtBQUssUUFBUSxHQUFHLElBQUkwQixNQUFNLENBQUNuRCxnRUFBTSxDQUFDeUIsSUFBSSxDQUFDLEVBQUUsR0FBRyxDQUFDLEdBQUdBLElBQUk7QUFDeEU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVN5QixVQUFVQSxDQUFDeEIsT0FBTyxFQUFFO0VBQzNCLE9BQU8sT0FBT0EsT0FBTyxLQUFLLFVBQVUsR0FDaENBLE9BQU8sR0FDUCxZQUFZO0lBQ1YsT0FBT0EsT0FBTztFQUNoQixDQUFDO0FBQ1AiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcWHhHb29cXHBlcnNvbmFsLXNpdGVcXG5vZGVfbW9kdWxlc1xcbWRhc3QtdXRpbC1maW5kLWFuZC1yZXBsYWNlXFxsaWJcXGluZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGltcG9ydCB7Tm9kZXMsIFBhcmVudHMsIFBocmFzaW5nQ29udGVudCwgUm9vdCwgVGV4dH0gZnJvbSAnbWRhc3QnXG4gKiBAaW1wb3J0IHtCdWlsZFZpc2l0b3IsIFRlc3QsIFZpc2l0b3JSZXN1bHR9IGZyb20gJ3VuaXN0LXV0aWwtdmlzaXQtcGFyZW50cydcbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIFJlZ0V4cE1hdGNoT2JqZWN0XG4gKiAgIEluZm8gb24gdGhlIG1hdGNoLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IGluZGV4XG4gKiAgIFRoZSBpbmRleCBvZiB0aGUgc2VhcmNoIGF0IHdoaWNoIHRoZSByZXN1bHQgd2FzIGZvdW5kLlxuICogQHByb3BlcnR5IHtzdHJpbmd9IGlucHV0XG4gKiAgIEEgY29weSBvZiB0aGUgc2VhcmNoIHN0cmluZyBpbiB0aGUgdGV4dCBub2RlLlxuICogQHByb3BlcnR5IHtbLi4uQXJyYXk8UGFyZW50cz4sIFRleHRdfSBzdGFja1xuICogICBBbGwgYW5jZXN0b3JzIG9mIHRoZSB0ZXh0IG5vZGUsIHdoZXJlIHRoZSBsYXN0IG5vZGUgaXMgdGhlIHRleHQgaXRzZWxmLlxuICpcbiAqIEB0eXBlZGVmIHtSZWdFeHAgfCBzdHJpbmd9IEZpbmRcbiAqICAgUGF0dGVybiB0byBmaW5kLlxuICpcbiAqICAgU3RyaW5ncyBhcmUgZXNjYXBlZCBhbmQgdGhlbiB0dXJuZWQgaW50byBnbG9iYWwgZXhwcmVzc2lvbnMuXG4gKlxuICogQHR5cGVkZWYge0FycmF5PEZpbmRBbmRSZXBsYWNlVHVwbGU+fSBGaW5kQW5kUmVwbGFjZUxpc3RcbiAqICAgU2V2ZXJhbCBmaW5kIGFuZCByZXBsYWNlcywgaW4gYXJyYXkgZm9ybS5cbiAqXG4gKiBAdHlwZWRlZiB7W0ZpbmQsIFJlcGxhY2U/XX0gRmluZEFuZFJlcGxhY2VUdXBsZVxuICogICBGaW5kIGFuZCByZXBsYWNlIGluIHR1cGxlIGZvcm0uXG4gKlxuICogQHR5cGVkZWYge1JlcGxhY2VGdW5jdGlvbiB8IHN0cmluZyB8IG51bGwgfCB1bmRlZmluZWR9IFJlcGxhY2VcbiAqICAgVGhpbmcgdG8gcmVwbGFjZSB3aXRoLlxuICpcbiAqIEBjYWxsYmFjayBSZXBsYWNlRnVuY3Rpb25cbiAqICAgQ2FsbGJhY2sgY2FsbGVkIHdoZW4gYSBzZWFyY2ggbWF0Y2hlcy5cbiAqIEBwYXJhbSB7Li4uYW55fSBwYXJhbWV0ZXJzXG4gKiAgIFRoZSBwYXJhbWV0ZXJzIGFyZSB0aGUgcmVzdWx0IG9mIGNvcnJlc3BvbmRpbmcgc2VhcmNoIGV4cHJlc3Npb246XG4gKlxuICogICAqIGB2YWx1ZWAgKGBzdHJpbmdgKSDigJQgd2hvbGUgbWF0Y2hcbiAqICAgKiBgLi4uY2FwdHVyZWAgKGBBcnJheTxzdHJpbmc+YCkg4oCUIG1hdGNoZXMgZnJvbSByZWdleCBjYXB0dXJlIGdyb3Vwc1xuICogICAqIGBtYXRjaGAgKGBSZWdFeHBNYXRjaE9iamVjdGApIOKAlCBpbmZvIG9uIHRoZSBtYXRjaFxuICogQHJldHVybnMge0FycmF5PFBocmFzaW5nQ29udGVudD4gfCBQaHJhc2luZ0NvbnRlbnQgfCBzdHJpbmcgfCBmYWxzZSB8IG51bGwgfCB1bmRlZmluZWR9XG4gKiAgIFRoaW5nIHRvIHJlcGxhY2Ugd2l0aC5cbiAqXG4gKiAgICogd2hlbiBgbnVsbGAsIGB1bmRlZmluZWRgLCBgJydgLCByZW1vdmUgdGhlIG1hdGNoXG4gKiAgICog4oCmb3Igd2hlbiBgZmFsc2VgLCBkbyBub3QgcmVwbGFjZSBhdCBhbGxcbiAqICAgKiDigKZvciB3aGVuIGBzdHJpbmdgLCByZXBsYWNlIHdpdGggYSB0ZXh0IG5vZGUgb2YgdGhhdCB2YWx1ZVxuICogICAqIOKApm9yIHdoZW4gYE5vZGVgIG9yIGBBcnJheTxOb2RlPmAsIHJlcGxhY2Ugd2l0aCB0aG9zZSBub2Rlc1xuICpcbiAqIEB0eXBlZGVmIHtbUmVnRXhwLCBSZXBsYWNlRnVuY3Rpb25dfSBQYWlyXG4gKiAgIE5vcm1hbGl6ZWQgZmluZCBhbmQgcmVwbGFjZS5cbiAqXG4gKiBAdHlwZWRlZiB7QXJyYXk8UGFpcj59IFBhaXJzXG4gKiAgIEFsbCBmaW5kIGFuZCByZXBsYWNlZC5cbiAqXG4gKiBAdHlwZWRlZiBPcHRpb25zXG4gKiAgIENvbmZpZ3VyYXRpb24uXG4gKiBAcHJvcGVydHkge1Rlc3QgfCBudWxsIHwgdW5kZWZpbmVkfSBbaWdub3JlXVxuICogICBUZXN0IGZvciB3aGljaCBub2RlcyB0byBpZ25vcmUgKG9wdGlvbmFsKS5cbiAqL1xuXG5pbXBvcnQgZXNjYXBlIGZyb20gJ2VzY2FwZS1zdHJpbmctcmVnZXhwJ1xuaW1wb3J0IHt2aXNpdFBhcmVudHN9IGZyb20gJ3VuaXN0LXV0aWwtdmlzaXQtcGFyZW50cydcbmltcG9ydCB7Y29udmVydH0gZnJvbSAndW5pc3QtdXRpbC1pcydcblxuLyoqXG4gKiBGaW5kIHBhdHRlcm5zIGluIGEgdHJlZSBhbmQgcmVwbGFjZSB0aGVtLlxuICpcbiAqIFRoZSBhbGdvcml0aG0gc2VhcmNoZXMgdGhlIHRyZWUgaW4gKnByZW9yZGVyKiBmb3IgY29tcGxldGUgdmFsdWVzIGluIGBUZXh0YFxuICogbm9kZXMuXG4gKiBQYXJ0aWFsIG1hdGNoZXMgYXJlIG5vdCBzdXBwb3J0ZWQuXG4gKlxuICogQHBhcmFtIHtOb2Rlc30gdHJlZVxuICogICBUcmVlIHRvIGNoYW5nZS5cbiAqIEBwYXJhbSB7RmluZEFuZFJlcGxhY2VMaXN0IHwgRmluZEFuZFJlcGxhY2VUdXBsZX0gbGlzdFxuICogICBQYXR0ZXJucyB0byBmaW5kLlxuICogQHBhcmFtIHtPcHRpb25zIHwgbnVsbCB8IHVuZGVmaW5lZH0gW29wdGlvbnNdXG4gKiAgIENvbmZpZ3VyYXRpb24gKHdoZW4gYGZpbmRgIGlzIG5vdCBgRmluZGApLlxuICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAqICAgTm90aGluZy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZpbmRBbmRSZXBsYWNlKHRyZWUsIGxpc3QsIG9wdGlvbnMpIHtcbiAgY29uc3Qgc2V0dGluZ3MgPSBvcHRpb25zIHx8IHt9XG4gIGNvbnN0IGlnbm9yZWQgPSBjb252ZXJ0KHNldHRpbmdzLmlnbm9yZSB8fCBbXSlcbiAgY29uc3QgcGFpcnMgPSB0b1BhaXJzKGxpc3QpXG4gIGxldCBwYWlySW5kZXggPSAtMVxuXG4gIHdoaWxlICgrK3BhaXJJbmRleCA8IHBhaXJzLmxlbmd0aCkge1xuICAgIHZpc2l0UGFyZW50cyh0cmVlLCAndGV4dCcsIHZpc2l0b3IpXG4gIH1cblxuICAvKiogQHR5cGUge0J1aWxkVmlzaXRvcjxSb290LCAndGV4dCc+fSAqL1xuICBmdW5jdGlvbiB2aXNpdG9yKG5vZGUsIHBhcmVudHMpIHtcbiAgICBsZXQgaW5kZXggPSAtMVxuICAgIC8qKiBAdHlwZSB7UGFyZW50cyB8IHVuZGVmaW5lZH0gKi9cbiAgICBsZXQgZ3JhbmRwYXJlbnRcblxuICAgIHdoaWxlICgrK2luZGV4IDwgcGFyZW50cy5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IHBhcmVudCA9IHBhcmVudHNbaW5kZXhdXG4gICAgICAvKiogQHR5cGUge0FycmF5PE5vZGVzPiB8IHVuZGVmaW5lZH0gKi9cbiAgICAgIGNvbnN0IHNpYmxpbmdzID0gZ3JhbmRwYXJlbnQgPyBncmFuZHBhcmVudC5jaGlsZHJlbiA6IHVuZGVmaW5lZFxuXG4gICAgICBpZiAoXG4gICAgICAgIGlnbm9yZWQoXG4gICAgICAgICAgcGFyZW50LFxuICAgICAgICAgIHNpYmxpbmdzID8gc2libGluZ3MuaW5kZXhPZihwYXJlbnQpIDogdW5kZWZpbmVkLFxuICAgICAgICAgIGdyYW5kcGFyZW50XG4gICAgICAgIClcbiAgICAgICkge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgZ3JhbmRwYXJlbnQgPSBwYXJlbnRcbiAgICB9XG5cbiAgICBpZiAoZ3JhbmRwYXJlbnQpIHtcbiAgICAgIHJldHVybiBoYW5kbGVyKG5vZGUsIHBhcmVudHMpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZSBhIHRleHQgbm9kZSB3aGljaCBpcyBub3QgaW4gYW4gaWdub3JlZCBwYXJlbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7VGV4dH0gbm9kZVxuICAgKiAgIFRleHQgbm9kZS5cbiAgICogQHBhcmFtIHtBcnJheTxQYXJlbnRzPn0gcGFyZW50c1xuICAgKiAgIFBhcmVudHMuXG4gICAqIEByZXR1cm5zIHtWaXNpdG9yUmVzdWx0fVxuICAgKiAgIFJlc3VsdC5cbiAgICovXG4gIGZ1bmN0aW9uIGhhbmRsZXIobm9kZSwgcGFyZW50cykge1xuICAgIGNvbnN0IHBhcmVudCA9IHBhcmVudHNbcGFyZW50cy5sZW5ndGggLSAxXVxuICAgIGNvbnN0IGZpbmQgPSBwYWlyc1twYWlySW5kZXhdWzBdXG4gICAgY29uc3QgcmVwbGFjZSA9IHBhaXJzW3BhaXJJbmRleF1bMV1cbiAgICBsZXQgc3RhcnQgPSAwXG4gICAgLyoqIEB0eXBlIHtBcnJheTxOb2Rlcz59ICovXG4gICAgY29uc3Qgc2libGluZ3MgPSBwYXJlbnQuY2hpbGRyZW5cbiAgICBjb25zdCBpbmRleCA9IHNpYmxpbmdzLmluZGV4T2Yobm9kZSlcbiAgICBsZXQgY2hhbmdlID0gZmFsc2VcbiAgICAvKiogQHR5cGUge0FycmF5PFBocmFzaW5nQ29udGVudD59ICovXG4gICAgbGV0IG5vZGVzID0gW11cblxuICAgIGZpbmQubGFzdEluZGV4ID0gMFxuXG4gICAgbGV0IG1hdGNoID0gZmluZC5leGVjKG5vZGUudmFsdWUpXG5cbiAgICB3aGlsZSAobWF0Y2gpIHtcbiAgICAgIGNvbnN0IHBvc2l0aW9uID0gbWF0Y2guaW5kZXhcbiAgICAgIC8qKiBAdHlwZSB7UmVnRXhwTWF0Y2hPYmplY3R9ICovXG4gICAgICBjb25zdCBtYXRjaE9iamVjdCA9IHtcbiAgICAgICAgaW5kZXg6IG1hdGNoLmluZGV4LFxuICAgICAgICBpbnB1dDogbWF0Y2guaW5wdXQsXG4gICAgICAgIHN0YWNrOiBbLi4ucGFyZW50cywgbm9kZV1cbiAgICAgIH1cbiAgICAgIGxldCB2YWx1ZSA9IHJlcGxhY2UoLi4ubWF0Y2gsIG1hdGNoT2JqZWN0KVxuXG4gICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICB2YWx1ZSA9IHZhbHVlLmxlbmd0aCA+IDAgPyB7dHlwZTogJ3RleHQnLCB2YWx1ZX0gOiB1bmRlZmluZWRcbiAgICAgIH1cblxuICAgICAgLy8gSXQgd2FzbuKAmXQgYSBtYXRjaCBhZnRlciBhbGwuXG4gICAgICBpZiAodmFsdWUgPT09IGZhbHNlKSB7XG4gICAgICAgIC8vIEZhbHNlIGFjdHMgYXMgaWYgdGhlcmUgd2FzIG5vIG1hdGNoLlxuICAgICAgICAvLyBTbyB3ZSBuZWVkIHRvIHJlc2V0IGBsYXN0SW5kZXhgLCB3aGljaCBjdXJyZW50bHkgYmVpbmcgYXQgdGhlIGVuZCBvZlxuICAgICAgICAvLyB0aGUgY3VycmVudCBtYXRjaCwgdG8gdGhlIGJlZ2lubmluZy5cbiAgICAgICAgZmluZC5sYXN0SW5kZXggPSBwb3NpdGlvbiArIDFcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChzdGFydCAhPT0gcG9zaXRpb24pIHtcbiAgICAgICAgICBub2Rlcy5wdXNoKHtcbiAgICAgICAgICAgIHR5cGU6ICd0ZXh0JyxcbiAgICAgICAgICAgIHZhbHVlOiBub2RlLnZhbHVlLnNsaWNlKHN0YXJ0LCBwb3NpdGlvbilcbiAgICAgICAgICB9KVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgbm9kZXMucHVzaCguLi52YWx1ZSlcbiAgICAgICAgfSBlbHNlIGlmICh2YWx1ZSkge1xuICAgICAgICAgIG5vZGVzLnB1c2godmFsdWUpXG4gICAgICAgIH1cblxuICAgICAgICBzdGFydCA9IHBvc2l0aW9uICsgbWF0Y2hbMF0ubGVuZ3RoXG4gICAgICAgIGNoYW5nZSA9IHRydWVcbiAgICAgIH1cblxuICAgICAgaWYgKCFmaW5kLmdsb2JhbCkge1xuICAgICAgICBicmVha1xuICAgICAgfVxuXG4gICAgICBtYXRjaCA9IGZpbmQuZXhlYyhub2RlLnZhbHVlKVxuICAgIH1cblxuICAgIGlmIChjaGFuZ2UpIHtcbiAgICAgIGlmIChzdGFydCA8IG5vZGUudmFsdWUubGVuZ3RoKSB7XG4gICAgICAgIG5vZGVzLnB1c2goe3R5cGU6ICd0ZXh0JywgdmFsdWU6IG5vZGUudmFsdWUuc2xpY2Uoc3RhcnQpfSlcbiAgICAgIH1cblxuICAgICAgcGFyZW50LmNoaWxkcmVuLnNwbGljZShpbmRleCwgMSwgLi4ubm9kZXMpXG4gICAgfSBlbHNlIHtcbiAgICAgIG5vZGVzID0gW25vZGVdXG4gICAgfVxuXG4gICAgcmV0dXJuIGluZGV4ICsgbm9kZXMubGVuZ3RoXG4gIH1cbn1cblxuLyoqXG4gKiBUdXJuIGEgdHVwbGUgb3IgYSBsaXN0IG9mIHR1cGxlcyBpbnRvIHBhaXJzLlxuICpcbiAqIEBwYXJhbSB7RmluZEFuZFJlcGxhY2VMaXN0IHwgRmluZEFuZFJlcGxhY2VUdXBsZX0gdHVwbGVPckxpc3RcbiAqICAgU2NoZW1hLlxuICogQHJldHVybnMge1BhaXJzfVxuICogICBDbGVhbiBwYWlycy5cbiAqL1xuZnVuY3Rpb24gdG9QYWlycyh0dXBsZU9yTGlzdCkge1xuICAvKiogQHR5cGUge1BhaXJzfSAqL1xuICBjb25zdCByZXN1bHQgPSBbXVxuXG4gIGlmICghQXJyYXkuaXNBcnJheSh0dXBsZU9yTGlzdCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCBmaW5kIGFuZCByZXBsYWNlIHR1cGxlIG9yIGxpc3Qgb2YgdHVwbGVzJylcbiAgfVxuXG4gIC8qKiBAdHlwZSB7RmluZEFuZFJlcGxhY2VMaXN0fSAqL1xuICAvLyBAdHMtZXhwZWN0LWVycm9yOiBjb3JyZWN0LlxuICBjb25zdCBsaXN0ID1cbiAgICAhdHVwbGVPckxpc3RbMF0gfHwgQXJyYXkuaXNBcnJheSh0dXBsZU9yTGlzdFswXSlcbiAgICAgID8gdHVwbGVPckxpc3RcbiAgICAgIDogW3R1cGxlT3JMaXN0XVxuXG4gIGxldCBpbmRleCA9IC0xXG5cbiAgd2hpbGUgKCsraW5kZXggPCBsaXN0Lmxlbmd0aCkge1xuICAgIGNvbnN0IHR1cGxlID0gbGlzdFtpbmRleF1cbiAgICByZXN1bHQucHVzaChbdG9FeHByZXNzaW9uKHR1cGxlWzBdKSwgdG9GdW5jdGlvbih0dXBsZVsxXSldKVxuICB9XG5cbiAgcmV0dXJuIHJlc3VsdFxufVxuXG4vKipcbiAqIFR1cm4gYSBmaW5kIGludG8gYW4gZXhwcmVzc2lvbi5cbiAqXG4gKiBAcGFyYW0ge0ZpbmR9IGZpbmRcbiAqICAgRmluZC5cbiAqIEByZXR1cm5zIHtSZWdFeHB9XG4gKiAgIEV4cHJlc3Npb24uXG4gKi9cbmZ1bmN0aW9uIHRvRXhwcmVzc2lvbihmaW5kKSB7XG4gIHJldHVybiB0eXBlb2YgZmluZCA9PT0gJ3N0cmluZycgPyBuZXcgUmVnRXhwKGVzY2FwZShmaW5kKSwgJ2cnKSA6IGZpbmRcbn1cblxuLyoqXG4gKiBUdXJuIGEgcmVwbGFjZSBpbnRvIGEgZnVuY3Rpb24uXG4gKlxuICogQHBhcmFtIHtSZXBsYWNlfSByZXBsYWNlXG4gKiAgIFJlcGxhY2UuXG4gKiBAcmV0dXJucyB7UmVwbGFjZUZ1bmN0aW9ufVxuICogICBGdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gdG9GdW5jdGlvbihyZXBsYWNlKSB7XG4gIHJldHVybiB0eXBlb2YgcmVwbGFjZSA9PT0gJ2Z1bmN0aW9uJ1xuICAgID8gcmVwbGFjZVxuICAgIDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gcmVwbGFjZVxuICAgICAgfVxufVxuIl0sIm5hbWVzIjpbImVzY2FwZSIsInZpc2l0UGFyZW50cyIsImNvbnZlcnQiLCJmaW5kQW5kUmVwbGFjZSIsInRyZWUiLCJsaXN0Iiwib3B0aW9ucyIsInNldHRpbmdzIiwiaWdub3JlZCIsImlnbm9yZSIsInBhaXJzIiwidG9QYWlycyIsInBhaXJJbmRleCIsImxlbmd0aCIsInZpc2l0b3IiLCJub2RlIiwicGFyZW50cyIsImluZGV4IiwiZ3JhbmRwYXJlbnQiLCJwYXJlbnQiLCJzaWJsaW5ncyIsImNoaWxkcmVuIiwidW5kZWZpbmVkIiwiaW5kZXhPZiIsImhhbmRsZXIiLCJmaW5kIiwicmVwbGFjZSIsInN0YXJ0IiwiY2hhbmdlIiwibm9kZXMiLCJsYXN0SW5kZXgiLCJtYXRjaCIsImV4ZWMiLCJ2YWx1ZSIsInBvc2l0aW9uIiwibWF0Y2hPYmplY3QiLCJpbnB1dCIsInN0YWNrIiwidHlwZSIsInB1c2giLCJzbGljZSIsIkFycmF5IiwiaXNBcnJheSIsImdsb2JhbCIsInNwbGljZSIsInR1cGxlT3JMaXN0IiwicmVzdWx0IiwiVHlwZUVycm9yIiwidHVwbGUiLCJ0b0V4cHJlc3Npb24iLCJ0b0Z1bmN0aW9uIiwiUmVnRXhwIl0sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/mdast-util-find-and-replace/lib/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/mdast-util-find-and-replace/node_modules/escape-string-regexp/index.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/mdast-util-find-and-replace/node_modules/escape-string-regexp/index.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ escapeStringRegexp)\n/* harmony export */ });\nfunction escapeStringRegexp(string) {\n  if (typeof string !== 'string') {\n    throw new TypeError('Expected a string');\n  }\n\n  // Escape characters with special meaning either inside or outside character sets.\n  // Use a simple backslash escape when it’s always valid, and a `\\xnn` escape when the simpler form would be disallowed by Unicode patterns’ stricter grammar.\n  return string.replace(/[|\\\\{}()[\\]^$+*?.]/g, '\\\\$&').replace(/-/g, '\\\\x2d');\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbWRhc3QtdXRpbC1maW5kLWFuZC1yZXBsYWNlL25vZGVfbW9kdWxlcy9lc2NhcGUtc3RyaW5nLXJlZ2V4cC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQWUsU0FBU0Esa0JBQWtCQSxDQUFDQyxNQUFNLEVBQUU7RUFDbEQsSUFBSSxPQUFPQSxNQUFNLEtBQUssUUFBUSxFQUFFO0lBQy9CLE1BQU0sSUFBSUMsU0FBUyxDQUFDLG1CQUFtQixDQUFDO0VBQ3pDOztFQUVBO0VBQ0E7RUFDQSxPQUFPRCxNQUFNLENBQ1hFLE9BQU8sQ0FBQyxxQkFBcUIsRUFBRSxNQUFNLENBQUMsQ0FDdENBLE9BQU8sQ0FBQyxJQUFJLEVBQUUsT0FBTyxDQUFDO0FBQ3pCIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXFh4R29vXFxwZXJzb25hbC1zaXRlXFxub2RlX21vZHVsZXNcXG1kYXN0LXV0aWwtZmluZC1hbmQtcmVwbGFjZVxcbm9kZV9tb2R1bGVzXFxlc2NhcGUtc3RyaW5nLXJlZ2V4cFxcaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZXNjYXBlU3RyaW5nUmVnZXhwKHN0cmluZykge1xuXHRpZiAodHlwZW9mIHN0cmluZyAhPT0gJ3N0cmluZycpIHtcblx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCBhIHN0cmluZycpO1xuXHR9XG5cblx0Ly8gRXNjYXBlIGNoYXJhY3RlcnMgd2l0aCBzcGVjaWFsIG1lYW5pbmcgZWl0aGVyIGluc2lkZSBvciBvdXRzaWRlIGNoYXJhY3RlciBzZXRzLlxuXHQvLyBVc2UgYSBzaW1wbGUgYmFja3NsYXNoIGVzY2FwZSB3aGVuIGl04oCZcyBhbHdheXMgdmFsaWQsIGFuZCBhIGBcXHhubmAgZXNjYXBlIHdoZW4gdGhlIHNpbXBsZXIgZm9ybSB3b3VsZCBiZSBkaXNhbGxvd2VkIGJ5IFVuaWNvZGUgcGF0dGVybnPigJkgc3RyaWN0ZXIgZ3JhbW1hci5cblx0cmV0dXJuIHN0cmluZ1xuXHRcdC5yZXBsYWNlKC9bfFxcXFx7fSgpW1xcXV4kKyo/Ll0vZywgJ1xcXFwkJicpXG5cdFx0LnJlcGxhY2UoLy0vZywgJ1xcXFx4MmQnKTtcbn1cbiJdLCJuYW1lcyI6WyJlc2NhcGVTdHJpbmdSZWdleHAiLCJzdHJpbmciLCJUeXBlRXJyb3IiLCJyZXBsYWNlIl0sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/mdast-util-find-and-replace/node_modules/escape-string-regexp/index.js\n");

/***/ })

};
;